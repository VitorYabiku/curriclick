// Generated by AshTypescript
// Do not edit this file manually





export type Decimal = string;
export type UUID = string;

// JobListing Schema
export type JobListingResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "originalId" | "title" | "description" | "companyId" | "location" | "remoteAllowed" | "workType" | "formattedWorkType" | "minSalary" | "maxSalary" | "medSalary" | "payPeriod" | "currency" | "views" | "applies" | "originalListedTime" | "listedTime" | "expiry" | "closedTime" | "jobPostingUrl" | "applicationUrl" | "applicationType" | "formattedExperienceLevel" | "skillsDesc" | "postingDomain" | "sponsored" | "compensationType" | "normalizedSalary" | "zipCode" | "fips";
  id: UUID;
  originalId: string | null;
  title: string;
  description: string;
  companyId: UUID;
  location: string | null;
  remoteAllowed: boolean | null;
  workType: "CONTRACT" | "FULL_TIME" | "INTERNSHIP" | "OTHER" | "PART_TIME" | "TEMPORARY" | "VOLUNTEER" | null;
  formattedWorkType: string | null;
  minSalary: Decimal | null;
  maxSalary: Decimal | null;
  medSalary: Decimal | null;
  payPeriod: "BIWEEKLY" | "HOURLY" | "MONTHLY" | "WEEKLY" | "YEARLY" | null;
  currency: "AUD" | "BBD" | "CAD" | "EUR" | "GBP" | "USD" | "BRL" | null;
  views: number | null;
  applies: number | null;
  originalListedTime: number | null;
  listedTime: number | null;
  expiry: number | null;
  closedTime: number | null;
  jobPostingUrl: string | null;
  applicationUrl: string | null;
  applicationType: "ComplexOnsiteApply" | "OffsiteApply" | "SimpleOnsiteApply" | "UnknownApply" | null;
  formattedExperienceLevel: "Associate" | "Director" | "Entry level" | "Executive" | "Internship" | "Mid-Senior level" | null;
  skillsDesc: string | null;
  postingDomain: string | null;
  sponsored: number | null;
  compensationType: string | null;
  normalizedSalary: Decimal | null;
  zipCode: string | null;
  fips: string | null;
  company: { __type: "Relationship"; __resource: CompanyResourceSchema | null; };
};



// Company Schema
export type CompanyResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name" | "description";
  id: UUID;
  name: string;
  description: string | null;
};





export type JobListingFilterInput = {
  and?: Array<JobListingFilterInput>;
  or?: Array<JobListingFilterInput>;
  not?: Array<JobListingFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  originalId?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  title?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  companyId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  location?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  remoteAllowed?: {
    eq?: boolean;
    notEq?: boolean;
  };

  workType?: {
    eq?: "CONTRACT" | "FULL_TIME" | "INTERNSHIP" | "OTHER" | "PART_TIME" | "TEMPORARY" | "VOLUNTEER";
    notEq?: "CONTRACT" | "FULL_TIME" | "INTERNSHIP" | "OTHER" | "PART_TIME" | "TEMPORARY" | "VOLUNTEER";
    in?: Array<"CONTRACT" | "FULL_TIME" | "INTERNSHIP" | "OTHER" | "PART_TIME" | "TEMPORARY" | "VOLUNTEER">;
  };

  formattedWorkType?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  minSalary?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  maxSalary?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  medSalary?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  payPeriod?: {
    eq?: "BIWEEKLY" | "HOURLY" | "MONTHLY" | "WEEKLY" | "YEARLY";
    notEq?: "BIWEEKLY" | "HOURLY" | "MONTHLY" | "WEEKLY" | "YEARLY";
    in?: Array<"BIWEEKLY" | "HOURLY" | "MONTHLY" | "WEEKLY" | "YEARLY">;
  };

  currency?: {
    eq?: "AUD" | "BBD" | "CAD" | "EUR" | "GBP" | "USD" | "BRL";
    notEq?: "AUD" | "BBD" | "CAD" | "EUR" | "GBP" | "USD" | "BRL";
    in?: Array<"AUD" | "BBD" | "CAD" | "EUR" | "GBP" | "USD" | "BRL">;
  };

  views?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  applies?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  originalListedTime?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  listedTime?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  expiry?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  closedTime?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  jobPostingUrl?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  applicationUrl?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  applicationType?: {
    eq?: "ComplexOnsiteApply" | "OffsiteApply" | "SimpleOnsiteApply" | "UnknownApply";
    notEq?: "ComplexOnsiteApply" | "OffsiteApply" | "SimpleOnsiteApply" | "UnknownApply";
    in?: Array<"ComplexOnsiteApply" | "OffsiteApply" | "SimpleOnsiteApply" | "UnknownApply">;
  };

  formattedExperienceLevel?: {
    eq?: "Associate" | "Director" | "Entry level" | "Executive" | "Internship" | "Mid-Senior level";
    notEq?: "Associate" | "Director" | "Entry level" | "Executive" | "Internship" | "Mid-Senior level";
    in?: Array<"Associate" | "Director" | "Entry level" | "Executive" | "Internship" | "Mid-Senior level">;
  };

  skillsDesc?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  postingDomain?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  sponsored?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  compensationType?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  normalizedSalary?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  zipCode?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  fips?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };


  company?: CompanyFilterInput;

};
export type CompanyFilterInput = {
  and?: Array<CompanyFilterInput>;
  or?: Array<CompanyFilterInput>;
  not?: Array<CompanyFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  name?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };



};


// Utility Types

// Resource schema constraint
type TypedSchema = {
  __type: "Resource" | "TypedMap" | "Union";
  __primitiveFields: string;
};

// Utility type to convert union to intersection
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;

// Helper type to infer union field values, avoiding duplication between array and non-array unions
type InferUnionFieldValue<
  UnionSchema extends { __type: "Union"; __primitiveFields: any },
  FieldSelection extends any[],
> = UnionToIntersection<
  {
    [FieldIndex in keyof FieldSelection]: FieldSelection[FieldIndex] extends UnionSchema["__primitiveFields"]
      ? FieldSelection[FieldIndex] extends keyof UnionSchema
        ? { [P in FieldSelection[FieldIndex]]: UnionSchema[FieldSelection[FieldIndex]] }
        : never
      : FieldSelection[FieldIndex] extends Record<string, any>
        ? {
            [UnionKey in keyof FieldSelection[FieldIndex]]: UnionKey extends keyof UnionSchema
              ? UnionSchema[UnionKey] extends { __array: true; __type: "TypedMap"; __primitiveFields: infer TypedMapFields }
                ? FieldSelection[FieldIndex][UnionKey] extends any[]
                  ? Array<
                      UnionToIntersection<
                        {
                          [FieldIdx in keyof FieldSelection[FieldIndex][UnionKey]]: FieldSelection[FieldIndex][UnionKey][FieldIdx] extends TypedMapFields
                            ? FieldSelection[FieldIndex][UnionKey][FieldIdx] extends keyof UnionSchema[UnionKey]
                              ? { [P in FieldSelection[FieldIndex][UnionKey][FieldIdx]]: UnionSchema[UnionKey][P] }
                              : never
                            : never;
                        }[number]
                      >
                    > | null
                  : never
                : UnionSchema[UnionKey] extends { __type: "TypedMap"; __primitiveFields: infer TypedMapFields }
                  ? FieldSelection[FieldIndex][UnionKey] extends any[]
                    ? UnionToIntersection<
                        {
                          [FieldIdx in keyof FieldSelection[FieldIndex][UnionKey]]: FieldSelection[FieldIndex][UnionKey][FieldIdx] extends TypedMapFields
                            ? FieldSelection[FieldIndex][UnionKey][FieldIdx] extends keyof UnionSchema[UnionKey]
                              ? { [P in FieldSelection[FieldIndex][UnionKey][FieldIdx]]: UnionSchema[UnionKey][P] }
                              : never
                            : never;
                        }[number]
                      > | null
                    : never
                  : UnionSchema[UnionKey] extends TypedSchema
                    ? InferResult<UnionSchema[UnionKey], FieldSelection[FieldIndex][UnionKey]>
                    : never
              : never;
          }
        : never;
  }[number]
>;

type HasComplexFields<T extends TypedSchema> = keyof Omit<
  T,
  "__primitiveFields" | "__type" | T["__primitiveFields"]
> extends never
  ? false
  : true;

type ComplexFieldKeys<T extends TypedSchema> = keyof Omit<
  T,
  "__primitiveFields" | "__type" | T["__primitiveFields"]
>;

type LeafFieldSelection<T extends TypedSchema> = T["__primitiveFields"];

type ComplexFieldSelection<T extends TypedSchema> = {
  [K in ComplexFieldKeys<T>]?: T[K] extends {
    __type: "Relationship";
    __resource: infer Resource;
  }
    ? NonNullable<Resource> extends TypedSchema
      ? UnifiedFieldSelection<NonNullable<Resource>>[]
      : never
    : T[K] extends {
          __type: "ComplexCalculation";
          __returnType: infer ReturnType;
        }
      ? T[K] extends { __args: infer Args }
        ? NonNullable<ReturnType> extends TypedSchema
          ? {
              args: Args;
              fields: UnifiedFieldSelection<NonNullable<ReturnType>>[];
            }
          : { args: Args }
        : NonNullable<ReturnType> extends TypedSchema
          ? { fields: UnifiedFieldSelection<NonNullable<ReturnType>>[] }
          : never
      : T[K] extends { __type: "TypedMap"; __primitiveFields: infer PrimitiveFields }
        ? PrimitiveFields[]
        : T[K] extends { __type: "Union"; __primitiveFields: infer PrimitiveFields }
          ? T[K] extends { __array: true }
            ? (PrimitiveFields | {
                [UnionKey in keyof Omit<T[K], "__type" | "__primitiveFields" | "__array">]?: T[K][UnionKey] extends { __type: "TypedMap"; __primitiveFields: any }
                  ? T[K][UnionKey]["__primitiveFields"][]
                  : T[K][UnionKey] extends TypedSchema
                    ? UnifiedFieldSelection<T[K][UnionKey]>[]
                    : never;
              })[]
            : (PrimitiveFields | {
                [UnionKey in keyof Omit<T[K], "__type" | "__primitiveFields">]?: T[K][UnionKey] extends TypedSchema
                  ? T[K][UnionKey]["__primitiveFields"][]
                  : T[K][UnionKey] extends TypedSchema
                    ? UnifiedFieldSelection<T[K][UnionKey]>[]
                    : never;
              })[]
            : NonNullable<T[K]> extends TypedSchema
              ? UnifiedFieldSelection<NonNullable<T[K]>>[]
              : never;
};

// Main type: Use explicit base case detection to prevent infinite recursion
type UnifiedFieldSelection<T extends TypedSchema> =
  HasComplexFields<T> extends false
    ? LeafFieldSelection<T> // Base case: only primitives, no recursion
    : LeafFieldSelection<T> | ComplexFieldSelection<T>; // Recursive case

type InferFieldValue<
  T extends TypedSchema,
  Field,
> = Field extends T["__primitiveFields"]
  ? Field extends keyof T
    ? { [K in Field]: T[Field] }
    : never
  : Field extends Record<string, any>
    ? {
        [K in keyof Field]: K extends keyof T
          ? T[K] extends {
              __type: "Relationship";
              __resource: infer Resource;
            }
            ? NonNullable<Resource> extends TypedSchema
              ? T[K] extends { __array: true }
                ? Array<InferResult<NonNullable<Resource>, Field[K]>>
                : null extends Resource
                  ? InferResult<NonNullable<Resource>, Field[K]> | null
                  : InferResult<NonNullable<Resource>, Field[K]>
            : never
          : T[K] extends {
                __type: "ComplexCalculation";
                __returnType: infer ReturnType;
              }
            ? NonNullable<ReturnType> extends TypedSchema
              ? null extends ReturnType
                ? InferResult<NonNullable<ReturnType>, Field[K]["fields"]> | null
                : InferResult<NonNullable<ReturnType>, Field[K]["fields"]>
              : ReturnType
            : NonNullable<T[K]> extends { __type: "TypedMap"; __primitiveFields: infer TypedMapFields }
              ? NonNullable<T[K]> extends { __array: true }
                ? Field[K] extends any[]
                  ? null extends T[K]
                    ? Array<
                        UnionToIntersection<
                          {
                            [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends TypedMapFields
                              ? Field[K][FieldIndex] extends keyof NonNullable<T[K]>
                                ? { [P in Field[K][FieldIndex]]: NonNullable<T[K]>[P] }
                                : never
                              : never;
                          }[number]
                        >
                      > | null
                    : Array<
                        UnionToIntersection<
                          {
                            [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends TypedMapFields
                              ? Field[K][FieldIndex] extends keyof NonNullable<T[K]>
                                ? { [P in Field[K][FieldIndex]]: NonNullable<T[K]>[P] }
                                : never
                              : never;
                          }[number]
                        >
                      >
                  : never
                : Field[K] extends any[]
                  ? null extends T[K]
                    ? UnionToIntersection<
                        {
                          [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends TypedMapFields
                            ? Field[K][FieldIndex] extends keyof NonNullable<T[K]>
                              ? { [P in Field[K][FieldIndex]]: NonNullable<T[K]>[P] }
                              : never
                            : never;
                        }[number]
                      > | null
                    : UnionToIntersection<
                        {
                          [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends TypedMapFields
                            ? Field[K][FieldIndex] extends keyof T[K]
                              ? { [P in Field[K][FieldIndex]]: T[K][P] }
                              : never
                            : never;
                        }[number]
                      >
                  : never
              : T[K] extends { __type: "Union"; __primitiveFields: any }
                ? T[K] extends { __array: true }
                  ? {
                      [CurrentK in K]: T[CurrentK] extends { __type: "Union"; __primitiveFields: any }
                        ? Field[CurrentK] extends any[]
                          ? Array<InferUnionFieldValue<T[CurrentK], Field[CurrentK]>> | null
                          : never
                        : never
                    }
                  : {
                      [CurrentK in K]: T[CurrentK] extends { __type: "Union"; __primitiveFields: any }
                        ? Field[CurrentK] extends any[]
                          ? InferUnionFieldValue<T[CurrentK], Field[CurrentK]> | null
                          : never
                        : never
                    }
                  : NonNullable<T[K]> extends TypedSchema
                    ? null extends T[K]
                      ? InferResult<NonNullable<T[K]>, Field[K]> | null
                      : InferResult<NonNullable<T[K]>, Field[K]>
                    : never
          : never;
      }
    : never;

type InferResult<
  T extends TypedSchema,
  SelectedFields extends UnifiedFieldSelection<T>[] | undefined,
> = SelectedFields extends undefined
  ? {}
  : SelectedFields extends []
  ? {}
  : SelectedFields extends UnifiedFieldSelection<T>[]
  ? UnionToIntersection<
      {
        [K in keyof SelectedFields]: InferFieldValue<T, SelectedFields[K]>;
      }[number]
    >
  : {};

// Pagination conditional types
// Checks if a page configuration object has any pagination parameters
type HasPaginationParams<Page> =
  Page extends { offset: any } ? true :
  Page extends { after: any } ? true :
  Page extends { before: any } ? true :
  false;

// Infer which pagination type is being used from the page config
type InferPaginationType<Page> =
  Page extends { offset: any } ? "offset" :
  Page extends { after: any } | { before: any } ? "keyset" :
  never;

// Returns either non-paginated (array) or paginated result based on page params
// For single pagination type support (offset-only or keyset-only)
// @ts-ignore
// eslint-disable-next-line @typescript-eslint/no-unused-vars
type ConditionalPaginatedResult<
  Page,
  RecordType,
  PaginatedType
> = Page extends undefined
  ? RecordType
  : HasPaginationParams<Page> extends true
    ? PaginatedType
    : RecordType;

// For actions supporting both offset and keyset pagination
// Infers the specific pagination type based on which params were passed
type ConditionalPaginatedResultMixed<
  Page,
  RecordType,
  OffsetType,
  KeysetType
> = Page extends undefined
  ? RecordType
  : HasPaginationParams<Page> extends true
    ? InferPaginationType<Page> extends "offset"
      ? OffsetType
      : InferPaginationType<Page> extends "keyset"
        ? KeysetType
        : OffsetType | KeysetType  // Fallback to union if can't determine
    : RecordType;

export type SuccessDataFunc<T extends (...args: any[]) => Promise<any>> = Extract<
  Awaited<ReturnType<T>>,
  { success: true }
>["data"];


export type ErrorData<T extends (...args: any[]) => Promise<any>> = Extract<
  Awaited<ReturnType<T>>,
  { success: false }
>["errors"];

/**
 * Represents an error from an unsuccessful RPC call.
 *
 * This type matches the error structure defined in the AshTypescript.Rpc.Error protocol.
 *
 * @example
 * const error: AshRpcError = {
 *   type: "invalid_changes",
 *   message: "Invalid value for field %{field}",
 *   shortMessage: "Invalid changes",
 *   vars: { field: "email" },
 *   fields: ["email"],
 *   path: ["user", "email"],
 *   details: { suggestion: "Provide a valid email address" }
 * }
 */
export type AshRpcError = {
  /** Machine-readable error type (e.g., "invalid_changes", "not_found") */
  type: string;
  /** Full error message (may contain template variables like %{key}) */
  message: string;
  /** Concise version of the message */
  shortMessage: string;
  /** Variables to interpolate into the message template */
  vars: Record<string, any>;
  /** List of affected field names (for field-level errors) */
  fields: string[];
  /** Path to the error location in the data structure */
  path: string[];
  /** Optional map with extra details (e.g., suggestions, hints) */
  details?: Record<string, any>;
}

/**
 * Represents the result of a validation RPC call.
 *
 * All validation actions return this same structure, indicating either
 * successful validation or a list of validation errors.
 *
 * @example
 * // Successful validation
 * const result: ValidationResult = { success: true };
 *
 * // Failed validation
 * const result: ValidationResult = {
 *   success: false,
 *   errors: [
 *     {
 *       type: "required",
 *       message: "is required",
 *       shortMessage: "Required field",
 *       vars: { field: "email" },
 *       fields: ["email"],
 *       path: []
 *     }
 *   ]
 * };
 */
export type ValidationResult =
  | { success: true }
  | { success: false; errors: AshRpcError[]; };





// Helper Functions

/**
 * Configuration options for action RPC requests
 */
export interface ActionConfig {
  // Request data
  input?: Record<string, any>;
  primaryKey?: any;
  fields?: Array<string | Record<string, any>>; // Field selection
  filter?: Record<string, any>; // Filter options (for reads)
  sort?: string; // Sort options
  page?:
    | {
        // Offset-based pagination
        limit?: number;
        offset?: number;
        count?: boolean;
      }
    | {
        // Keyset pagination
        limit?: number;
        after?: string;
        before?: string;
      };

  // Metadata
  metadataFields?: ReadonlyArray<string>;

  // HTTP customization
  headers?: Record<string, string>; // Custom headers
  fetchOptions?: RequestInit; // Fetch options (signal, cache, etc.)
  customFetch?: (
    input: RequestInfo | URL,
    init?: RequestInit,
  ) => Promise<Response>;

  // Multitenancy
  tenant?: string; // Tenant parameter

  // Hook context
  hookCtx?: Record<string, any>;
}

/**
 * Configuration options for validation RPC requests
 */
export interface ValidationConfig {
  // Request data
  input?: Record<string, any>;

  // HTTP customization
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (
    input: RequestInfo | URL,
    init?: RequestInit,
  ) => Promise<Response>;

  // Hook context
  hookCtx?: Record<string, any>;
}




/**
 * Gets the CSRF token from the page's meta tag
 * Returns null if no CSRF token is found
 */
export function getPhoenixCSRFToken(): string | null {
  return document
    ?.querySelector("meta[name='csrf-token']")
    ?.getAttribute("content") || null;
}

/**
 * Builds headers object with CSRF token for Phoenix applications
 * Returns headers object with X-CSRF-Token (if available)
 */
export function buildCSRFHeaders(headers: Record<string, string> = {}): Record<string, string> {
  const csrfToken = getPhoenixCSRFToken();
  if (csrfToken) {
    headers["X-CSRF-Token"] = csrfToken;
  }

  return headers;
}

/**
 * Internal helper function for making action RPC requests
 * Handles hooks, request configuration, fetch execution, and error handling
 * @param config Configuration matching ActionConfig
 */
async function executeActionRpcRequest<T>(
  payload: Record<string, any>,
  config: ActionConfig
): Promise<T> {
    const processedConfig = config;

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
    ...processedConfig.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    ...processedConfig.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);
  const result = response.ok ? await response.json() : null;


  if (!response.ok) {
    return {
      success: false,
      errors: [
        {
          type: "network_error",
          message: `Network request failed: ${response.statusText}`,
          shortMessage: "Network error",
          vars: { statusCode: response.status, statusText: response.statusText },
          fields: [],
          path: [],
          details: { statusCode: response.status }
        }
      ],
    } as T;
  }

  return result as T;
}


/**
 * Internal helper function for making validation RPC requests
 * Handles hooks, request configuration, fetch execution, and error handling
 * @param config Configuration matching ValidationConfig
 */
async function executeValidationRpcRequest<T>(
  payload: Record<string, any>,
  config: ValidationConfig
): Promise<T> {
    const processedConfig = config;

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
    ...processedConfig.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    ...processedConfig.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);
  const result = response.ok ? await response.json() : null;


  if (!response.ok) {
    return {
      success: false,
      errors: [
        {
          type: "network_error",
          message: `Network request failed: ${response.statusText}`,
          shortMessage: "Network error",
          vars: { statusCode: response.status, statusText: response.statusText },
          fields: [],
          path: [],
          details: { statusCode: response.status }
        }
      ],
    } as T;
  }

  return result as T;
}









export type ListJobListingsFields = UnifiedFieldSelection<JobListingResourceSchema>[];


export type InferListJobListingsResult<
  Fields extends ListJobListingsFields,
> = {
  results: Array<InferResult<JobListingResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
};

export type ListJobListingsResult<Fields extends ListJobListingsFields> = | { success: true; data: InferListJobListingsResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function listJobListings<Fields extends ListJobListingsFields>(
  config: {
  fields: Fields;
  filter?: JobListingFilterInput;
  sort?: string;
  page: {
    limit?: number;
    after?: string;
    before?: string;
    offset?: never;
    count?: never;
  };
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ListJobListingsResult<Fields>> {
  const payload = {
    action: "list_job_listings",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListJobListingsResult<Fields>>(
    payload,
    config
  );
}


export async function validateListJobListings(
  config: {
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_job_listings"
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type GetJobListingFields = UnifiedFieldSelection<JobListingResourceSchema>[];


export type InferGetJobListingResult<
  Fields extends GetJobListingFields,
> = {
  results: Array<InferResult<JobListingResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
};

export type GetJobListingResult<Fields extends GetJobListingFields> = | { success: true; data: InferGetJobListingResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function getJobListing<Fields extends GetJobListingFields>(
  config: {
  fields: Fields;
  filter?: JobListingFilterInput;
  sort?: string;
  page: {
    limit?: number;
    after?: string;
    before?: string;
    offset?: never;
    count?: never;
  };
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetJobListingResult<Fields>> {
  const payload = {
    action: "get_job_listing",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<GetJobListingResult<Fields>>(
    payload,
    config
  );
}


export async function validateGetJobListing(
  config: {
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "get_job_listing"
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type FindMatchingJobsInput = {
  query?: string;
  profileContext?: string;
  limit?: number;
  minScore?: number;
  semanticAggregateBoost?: number;
  semanticTitleBoost?: number;
  semanticDescriptionBoost?: number;
  semanticSkillsBoost?: number;
  semanticQueryProfileBoost?: number;
  textTitleBoost?: number;
  textDescriptionBoost?: number;
  textSkillsBoost?: number;
  textQueryProfileBoost?: number;
  profileRemotePreference?: "remote_only" | "remote_friendly" | "hybrid" | "on_site" | "no_preference";
  workTypes?: Array<string>;
  remoteAllowed?: boolean;
};

export type InferFindMatchingJobsResult = Array<CurriclickCompaniesJobListingMatchResourceSchema>;

export type FindMatchingJobsResult = | { success: true; data: InferFindMatchingJobsResult; }
| { success: false; errors: AshRpcError[]; }

;

export async function findMatchingJobs(
  config: {
  input?: FindMatchingJobsInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<FindMatchingJobsResult> {
  const payload = {
    action: "find_matching_jobs",
    input: config.input
  };

  return executeActionRpcRequest<FindMatchingJobsResult>(
    payload,
    config
  );
}


export async function validateFindMatchingJobs(
  config: {
  input?: FindMatchingJobsInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "find_matching_jobs",
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListCompaniesFields = UnifiedFieldSelection<CompanyResourceSchema>[];


export type InferListCompaniesResult<
  Fields extends ListCompaniesFields | undefined,
  Page extends ListCompaniesConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<CompanyResourceSchema, Fields>>, {
  results: Array<InferResult<CompanyResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<CompanyResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListCompaniesConfig = {
  fields: ListCompaniesFields;
  filter?: CompanyFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListCompaniesResult<Fields extends ListCompaniesFields, Page extends ListCompaniesConfig["page"] = undefined> = | { success: true; data: InferListCompaniesResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

export async function listCompanies<Fields extends ListCompaniesFields, Config extends ListCompaniesConfig = ListCompaniesConfig>(
  config: Config & { fields: Fields }
): Promise<ListCompaniesResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_companies",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListCompaniesResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


export async function validateListCompanies(
  config: {
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_companies"
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


