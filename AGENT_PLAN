Context:
- Repo root: /home/vky/school/USP/EI/curriclick
- Backend resource: lib/curriclick/companies/job_listing.ex defines a read action :find_matching_jobs that loads a :match_score calculation and sorts by cosine similarity.
- Frontend consumer: assets/js/job-listings.tsx calls findMatchingJobs() and expects a camelCase matchScore field on each result.
- Test scripts: test_find_matching.exs and test_argument.exs are runnable via `mix run` (not ExUnit tests under test/).

Goal:
Fix the missing match_score in the RPC payload and improve the quality of similarity ranking for queries like "junior data analyst", while keeping to Ash/AshTypescript usage rules and avoiding edits to generated clients.

Approach (two phases):
- Phase 1 – Quick, safe fixes to unblock UI and improve ranking.
- Phase 2 – Optional refactor to a custom RPC action for cleaner argument passing (if we outgrow Phase 1).

Plan:
1) Frontend quick fix (required)
   - Add "matchScore" to the requested fields when calling findMatchingJobs in assets/js/job-listings.tsx so the calculation is included in the response.
     Example fields array: ["id", "jobRoleName", "description", "companyId", "matchScore"].
   - Until we refactor in Phase 2, call the RPC endpoint directly to pass action arguments, because the generated read helper does not accept input for arguments:
     - POST to "/rpc/run" with payload: { action: "find_matching_jobs", arguments: { ideal_job_description: <string> }, fields: [...] } using buildCSRFHeaders().
     - Keep the existing type mapping in JobCard and convert score to percent in the UI.

2) Ranking improvements (backend)
   - Keep using the existing cosine similarity, but add a minimum similarity filter in the prepare (e.g. >= 0.55) to drop irrelevant roles and tune @find_matching_limit (default 25).
   - Add a stable tie-breaker sort after similarity (e.g., job_role_name asc) to reduce jitter across runs with close scores.
   - Ensure :match_score stays public and loaded via Ash.Query.load with the computed search_vector.

3) Types and codegen (consistency)
   - Do not hand-edit assets/js/ash_rpc.ts. Regenerate after backend changes with: `mix ash_typescript.codegen --output assets/js/ash_rpc.ts`.
   - Verify the generated FindMatchingJobsFields union includes "matchScore" and that TypeScript type-checks.

4) Validation and tests
   - Run the ad-hoc scripts with `mix run test_find_matching.exs` and `mix run test_argument.exs` to manually verify presence of match_score and sensible ordering.
   - If needed, add an ExUnit test (e.g., test/find_matching_jobs_test.exs) that seeds two clearly different roles and asserts ordering and a minimum score threshold for a "data analyst" query.

5) Phase 2 (optional) – custom RPC action
   - If we want a typed, first-class argument API, convert :find_matching_jobs from a read to a custom action that accepts input and returns a shaped payload:
     - Replace `read :find_matching_jobs` with `action :find_matching_jobs, :map` and implement run/2 to execute the internal Ash.Query (limit, select required fields, load :match_score, sort, threshold) and return `%{results: [...], has_more: false, count: length(results)}`.
     - Keep rpc_action mapping in lib/curriclick/companies.ex: `rpc_action :find_matching_jobs, :find_matching_jobs`.
     - Regenerate the client and update assets/js/job-listings.tsx to call the new `findMatchingJobs({ input: { idealJobDescription }, headers })` shape (no manual fetch required). Note that the generated signature for custom actions will not include field selection; select needed fields in the backend query.

Notes:
- Respect AshTypescript rules: always use buildCSRFHeaders(), use `mix ash_typescript.codegen` after action changes, do not edit generated files by hand.
- Keep vector embeddings via vectorize/after_action; if results still look noisy, raise the similarity threshold gradually (e.g., 0.55 → 0.65) and/or cap description length via argument constraints.
